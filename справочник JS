Справочник по JS.

<meta charset="utf-8">
<script type="text/javascript">

</script>

// Начало и конец скрипта.

let Dollar = 65.5;

// Объявляем переменную в пределах блока.

var Dollar = 65.5;

// Объявляем глобальную переменную.

"\n"

// При выводе перенос на новую строку.

alert("" + f);

var x = prompt ("");

parseInt
parseFloat

// Парсим из строки (по умолчанию) переменные указанного типа.

Area.toFixed(2)

// обрезаем числа после запятой до 2-х.

var b = +prompt ("Введите второе число");

// + перед prompt - сразу parseInt

Операторы сравнения

a == b  (a = b - присваивание значения переменной)
a != b
a > b
a >= b
a <= b

Условия (ветвление):

if (a > b) {

	var max = a; 
} 
	else if (a ==b)	{ 

	alert ("Числа равны");
	max = a
}
	else {

		max = b;
	}
	
HTML:

<br /> - перенос строки.

document.write("Привет <br />");

// вывод на экран


i = i + 1;  =   i++;

// это одно и то же!

// Циклы:

for (var i=0; i <5; i++;) {

	document.write("Привет! <br />");
}

// или

var i = 0;

While(i<5) {

document.write("Привет! <br />");
i = i + 1;
}

if(isNaN(n)) {

}

// если n не число.

Сложные логические операции:

&& - И - одновременное выполнение условий.
|| - ИЛИ - хотя бы одно из условий.
! - НЕ

// Цикл do while:

do {
	var n = +prompt("Пожалуйста, введите положительное число");

   } while(isNaN(n) || n < 0) 


var answer = Math.random ();

// генерируется случайное число от 0 до 1.

break; // выйти из цикла
//continue; - переходим сразу к следующей итерации цикла

if(tryCount > maxTryCount)
		alert("Вы проиграли!");
		
// если после if идет только одна команда, {} не обязательны.

// Синтаксис

str.toLowerCase();

// преобразование строки в нижний регистр.

Math.round(); // возвращает число, округлённое к ближайшему целому.

var numbers = [42, 56, 96, 14, 28];

// массив, выводится:

numbers [2]; // 96, нумерация с 0

alert(numbers.length);

// длинна массива.

var numbers = [];
numbers.push(42); // заполнение пустого массива числами..
numbers.pop(); // убираем последний элемент массива
words.splice(i,1); // из массива words удаляем элемент i, начиная с него удаляем 1 элементам

var m = numbers.pop(); // и кладем его в переменную m

for (var i = 0; i < 5; i++){

var randomNumber = parseInt(Math.random()*100);
numbers.push(randomNumber);

}

// Создаем массив длинной 5 и заполняем его случайными числами.

// Двумерный массив, каждый его элемент - это тоже массив.

var words = [
["food", "еда"],
["bike", "велосипед"],
[apple], [яблоко],
];

// Обращение к элементам:

alert (words[0]); // food, еда
alert (words [0][0]); // food
alert (words [0][3]); // undefined

// Функции!

function sayHello(){

// тело функции

}

sayHello();

// вызов функции

function sayHello(name) {

document.write("Hello, " + name + " <br>");

}

sayHello("Mike");

// функция с переменной. переменная name существует только внутри функции.

function getRandomNumber (max) {

	var rand = Math.round(Math.random() * max);
	return rand;
	
// или return Math.round(Math.random() * max); - по короче

}

// функция возвращает обратно значение rand.

var n = getRandomNumber(100);

// ответ функции (rand) запишется в переменную n

function max(a,b){

	if(a>=b){
	
		return a;
	
	}	else {
	
		return b;
	// любые команды после команды return в функции никогда не выполнятся!
	}

}

var a = max (34, 68);
var c = max (a, 98) + 4;

// с функциямо можно делать математические операции, как показано
// выше с функцией max.

// Рекурсивная функция:

function recursiveFactorial(n) {

	if(n == 0)
		
		return 1;
	
	else 
		
		return recursiveFactorial(n-1)*n;

}

while(true) {

if...

}

// цикл работает до тех пор пока значение if не будет верным.

function maxMassive(massiv, max) {
	
//var max = 0;

		for (let i = 0; i <= (massiv.length - 2); i++) {

			if(massiv(i) >= massiv(i+1)) {

				max = massiv(i);           
	           
			} else {

				max = massiv(i+1);
			}
			
		}

	return max;

}

// Функция с двумя переменными.



let fruits = ["Яблоко", "Апельсин", "Слива"];

// текстовый массив.


var sum = 0;
		for (var i = 0; i < count.length; i++) {
			sum += count[i];	
		}
		
// sum = sum + ... -> sum += ...

///////////////////////////////////////////////////////////////////////////////////////////

Python


Преобразование типов переменных:

str(number) - число к строке
int(word) - строка к числу

print(type(person_name))

// печатаем тип переменной

print дополнительные возможности: вывод через запятую: , - если нам нужно распечатать числовую
и строковую переменную, оператор преобразует все данные в строковые и выводит их через пробел
например 

name = 'Кеша'
age = 2

print (name, age)

если мы хотим распечатать данные через другой разделитель, используем:  sep= 

print (name, age, sep='/')

--> Кеша/2

Перенос строки: =end

print(name, end=';')
print(age, end=';')
print(end, end=';')

--> Кеша;2;end;

Склеили + разделитель в конце после каждой переменной.

Ввод данных:

name = input('Как тебя зовут?')

// !!!результат всегда str

 результат деления всегда float, кроме случая когда:
 
 // - целая часть от деления.
 
 % - остаток от деления.
 
 (не,в арифметике остаток это сколько единиц после того как вытащили столько то раз число, на которое делим)
 
import math
frac, whole = math.modf(2.5)
 
 
 ** - возведение в степень.
 
 Условия:
 
 print ('Ваш возраст равен среднему', ale == age) 
 
 --> Ваш возраст равен среднему True - результат логической операции.
 
 print ('У вас юбилей', age%5 ==0)

--> У вас юбилей True.

комбинируем условие с операцией.

Логические выражения комбинируются:

and
or
not

Условия:

if age < 18:
    print('Доступ запрещен')
	
// Блоки кода разделяются отступами (4* пробела или отступ)
else:
    print('Доступ разрешен')

if - elif - else
(elif - else if)

Внутрь if может быть вложен другой if.

Циклы:

while name != 'Гвидо':
	print ''
	
print('Верно')

// while - условие - пока оно выполняется, цикл повторяется, тело цикла - через таб.

number = number + 1
number += 1

number = number - 1
number -=1

// это одно и тоже!

break - выходим из цикла

while True:
	name =
	...
	break

// Все время крутимся в цикле пока не выпадет условие break, оно должно быть
// обязательно!

continue - переходим на следующую итерацию цикла, не выполняя то, что после continue.

while-else
выполняется дествие после того как условие цикла стало неверным (False)

while number <= 100:
	print(number)
	number +=1
else:
	print('end')

// блок выполнится только тогда когда мы выйдем из цикла по условию.
// в случае break - не выполнится!

Строки:

friend = 'Максим'
friend = "Максим"

// главное чтобы кавычки были одинакового типа
// если в строке кавычки должны быть, то мы можем поставить кавычки другого типа внутри строки

say = 'say "Hello"'
print(say)

можно получить символ по индексу, они начинаются с 0

first_letter = friend[0]
print(first_letter)

----> M

last_letter = friend [-1]

// индексация с конца

Срез:

friend [1:4]
с 1го по 4й символ.
friend [:4]
с начала до 4го символа
friend [3:]
с 3го символа до конца

тип среза - тоже str

Методы со строками: 
Фунция:
len(friend) сколько символов в строке
Методы:
friend.find('a') - результат индекс буквы/подстроки. Если нет - "-1"
friend.split() разбиваем строку через пробел
Получаем две строки 

'Максим Леонид' --> ['Максим', 'Леонид']

friend.split(',') - теперь разделитель запятая.

friend.isdigit() строка состоит из чисел - проверка

Вернет True/False

friend.upper() верхний регистр
friend.lower()

Функция help(str)

Форматирование строк:

- конкатенация ('Привет ' + str(name)')
-% ('Привет %s тебе %d лет'%(name, age)) - s/d - формат данных
-format ('Привет {} тебе {} лет'.format(name, age))
# или так: print(f'Попытка № {count}')

(формат данных не указываем, их указывает сам Питон)

Списки и кортежи.

Списки (list)

some_list = ['hello', 1, 'five']

тип списка - list

нумерация с 0

friends = ['Max','Leo','Kate']

print(type(friend))

--> list

print('Второй друг: ', friends[1])
print('Первый друг с конца: ', friends[-1])

Срезы:

print(friends[1:2])

--> ['Leo'] - получаем другие списки.

len(friends) - сколько элементов в списке
friends.append('Ron') - добавление нового элементам
friends.pop() - удаляем последний элемент и возвращаем его
friend.clear() - очищаем весь список
friends.remove('Ron') - удаление объекта из списка
friends.reverse() - переворот списка

del friends[0] - удаление элемента по индексу

Оператор in:

Проверяет наличие элемента в списке:

'Max' in friends

--> True/False

Также работает со строчками.

 if 'man' in hero:
	print('Есть')
	
или же

if hero.find('man') != -1:
	print('Есть')
	
Кортеж tuple - список, который нельзя менять.

roles=('user', 'manager', 'admin')

sorted(members) - список отсортирован по алфавиту.

Последовательность - контейнер, элементы которого представляют собой порядок(последовательность).

Утиная типизация - если в объекте содержится реализация методов последовательности -
он будет считаться последовательностью.

Цикл for!

Перебор элементов последовательности по порядку без указания индекса.

for friend in friends:
	print(friend)
	
Заканчивается когда заканчивается последовательность элементов.

Функция range.

позволяет создать последовательность целых чисел.

numbers = range(10)

print(numbers) --> range(0, 10)

print(list(numbers)) # привели к типу list

--> [0,1,2,3,4,5,6,7,8,9]

for i in range(len(winners)):
	print(i+1, ")", winners[i])
	
# for range используется когда нужен индекс в цикле.
	
Параметры range:

range(start_or_stop, stop[, step])

print(list(range (1,1000,2))) # выводим нечетные числа

for number in range(1,1000,2):
	print(number)

# в строку и в столбик

Словари.

dict
Неупорядоченная коллекция произвольных объектов с доступом по ключу.

my_dict = {key1:val1, key2:val2, ...}

friend = {

'name': 'Max',
'age': 23

}

класс переменной friend - dict.

Основные действия со словарем:

Получение элемента по ключу: friend['name']
добавлеине значения friend['has_car'] = True
изменение значения friend['has_car'] = False
удаление значения remove friend['age']
оператор in 'age' in friend работает по ключам.

В словаре с одним ключем может быть только 1 значение.

Перебор словаря циклом:

По ключам:

for key in friend.keys():
	print(key)

--> список ключей

for key in friend

# тоже самое, что и выше - перебор по ключам.

По значениям:

for val in fruend.values():
	print(val)
	
--> значения словаря

По парам ключ + значение:

for item in friends.items():

		print(item)
		
# item возвращает список из кортежей.

for key, val in friend.items():
	print(key)
	print(val)

# картежи распадуться на переменные.

Множества.

set

Неупорядоченная коллеция, содержащая не повторяющиеся элементы.
(нет двух одинаковых)

cities={'Las Vegas','Paris','Moscow'}

если есть повторяющиеся элементы в списке и мы хотим убрать дубли, просто приводим
список к множеству:

cities = set(cities)

Действия со множествами:

добавление элемента cities.add('Burma')
удаление элемента cities.remove('Moscow')
длина множества len(cities)
оператор in, цикл for
for city in citites:
	print(city)

работа с несколькими множествами - объединение, пересечение и др.
объединение &
пересечение |
вычитание -

Если мы идем по списку и удаляем данные из него же, то
мы должны идти по циклом по копии списка:

for number in a[:]: # копия - срез этого же списка с первого до последнего элемента
	if number in b:
		a.remove(number)
		
print(a)

# импортируем подуль random

import random

number = random.randint(1, 100)
# хотим целое число от 1 до 100...

Функции.
нужно для повторого использования кода, для создания блоков программы.
Часть кода, которая вызывается из другого места программы.

Примеры: print, input, range и т.д.

abs - модуль
min max
round(число, сколько знаков после ,) округлить число
sum сумма элементов последовательности
enumerate - пронумеровать последовательность

Функция:
def print_sep(sep, sep_len):
	print(sep * sep_len)
	# return sep * sep_len - функция возвращает значение.

Вызов:
print_sep('*', 100)

В скобках - параметры.

Параметры функции можно передавать по порядку или по имени:

greeting(say='Hi', who='Leo')

# название параметра, потом передаваемое значение.

Значения по умолчанию у параметров.

def greeting(who, say='Hello')

# параметр по умолчанию задаем при объявлении.

Передача любого количества параметров:

args, kwargs
args - передача любого количества по порядку.
kwargs - передва любого количества по имени.

def greeting(say, *who)

*who - можно задать любое количества параметров, это стандартно называется *args
можно передавать кортеж из значений.

**who (**kwargs) - сколько угодно параметров по имени, приходит словарь.

def get_person(**kwargs)

	for k, v in kwargs.items():
		print(k,v)
		
get_person (name='Leo', age=20, has_car=True)

-->

name Leo
age 20
has_car True

Область видимости - область программы в пределах которой ID переменной 
продолжает быть связанным с этой переменной и возвращать ее значение.

Глобальные объекты - во всем файле, локальные объявлены только внутри ф. и там
же и видны.

global my_var - делаем переменную глобальной, даже внутри ф.
даем доступ на ее изменение.

global_var = 1

def my_f()
	global global_var # без этой строчки поменять переменную внутри функции не получится.
	global_var=999	  # она так и останется = 1 и будет ошибка.

my_f()	
print(global_var)

Относительность области видимости:

def a()

	def b()
	mb = 'ляляля'

		def c()

mb видно в c(), но не видно в a()

def some_f():
	return 10

a = some_f

# переменную а записано не значение которое возвращает функция, а сама функция some_f

Т.о. ф. сама по себе объект, ее можно записать в какую-то переменную.

print(type(a)) --> function

print(a())  --> 10

Функцию можно передавать параметром в другие функции!

def f():
	print('Hello from other f')
	
def to(f_param):
	f_param() #параметр - ф., которую мы вызываем.
	
to(f) # передаем в функцию другую функцию.

--> Hello from other f

lambda ф.

lambda входные параметры: результат

Т.е. или так:

def is_even(number):
	return number % 2 == 0

print(my_filter(numbers, is_even))

	или так:
	
print(my_filter(numbers, lambda number: number % 2 == 0))

# ключевое слово lambda, потом параметр, потом двоеточие и возвращаемое значение.

Функция sorted.

Сортирует последовательности:

sorted(iterable, *, key=None, reverse=False)

агрументы: последовательность, ключ для сортировки, порядок.

cities = [('Москва',1000),('Лас-Вегас',500),('Антверпен',2000)]

если print(sorted(cities)) - вывод сортировка по алфавиту.

def by_count(city):
	return city[1]   # говорим ф. сортед, что ключ - второй элемент кортежа.

print(sorted(cities, key=by_count))
# передаем саму функцию - пишем без параметров.

или

print(sorted(cities, key=lambda cuty:city[1]))

filter

фильтрует последовательности

filter(function, iterable)
аргументы: функция фильтрации, последовательность.

print(list(filter(lambda x: len(x)>3, names)))

--> ['Kate']

То слово в списке, где больше 3х символов.

map

применяет функцию к каждому элементу последовательности. Т.е. получает новую последовательность.

map (func, iterable, ...)

функция, последовательность

print(list(map(lambda x: x**2, numbers)))

возводит каждое число последовательности numbers в квадрат.

Модули.

Любой файл с программой.

Нужен для повторного использования кода.
Управление пространством имен (можно придумывать одинаковые имена и использовать
в разных частях кода).

- встроенные модули (math, random,..)
- сторонние модули (django, pyQt5,..)
- наши собственные модули (любой файл .py)

Варианты подключения:

import math импортируется целиком.
import math as mt импортируется как псевдоним.
from math import * - импортируется только содержимое.
from math import sin, cos, ... импорт конкретный ф., классов

import math

print(math.pi) --> 3.14159... получаем число пи.
---------------------------------
import random as rd

print(rd.randint(1, 10))
---------------------------------
from math import *

print(pi) - теперь вызываем без указания модуля.
# не рекомендуется, т.к. могу быть накладки по именами, которые уже есть в модуле.
---------------------------------

from random import randint

print(randint(1,10))

---------------------------------

Math
Математические функции.

factorial
exp
log, log2, log10
sqrt - корень
sin, cos, asin, asoc и др.

Найти длину окружности:

import math

r = 100 
print(2*r*math.pi)

--> 628.318...

math.pow(r,2) - возведение в квадрат.. или r**2

math.sqrt() - квадратный корень.

print(math.factorial(9)) - факториал 9-ти.

Random.

randint(0, 100) - случайное число из диопазона.
choice(players) - случайный элемент последовательности.
shuffe(cards)
print(cards) - перемешивает последовательность, не возвращает значения, печатаем
отдельно.
random - случайное число от 0 до 1
sample(players, 3) - список длиной k из последовательности,выбрали 3х победителей
из списка и др.

Создание своего модуля.

это файл с расшрением .py

При импорте нужно учитывать путь до нашего модуля.

import firstmodule
import folder.firstmodule

import moda
from forderb.modb import foo, bar

теперь можем вызывать переменные и функции из модулей.

print(foo)
bar()

Модули со скриптами.

При любом импорте скрипты будут выполняться, если не указано никаких условий
if __name__ == '__main__'

import modc # если в модуле стяло print('Я выполняюсь всегда'), то сразу при
импорте фраза печатается в консоль.

from modc import foo

# print все равно выполняется, хотя мы импортируем только переменную.

if __name__ == '__main__' - ограничивает выполнение скриптов.

Модуль modc.py :

foo = 'foo C'

if __name__ == '__main__':  - это условие выполняется только изнутри модуля,
при импорте переменная __name__ равняется имени файла.

print('Я выполняюсь всегда, ну, почти всегда..')

При импорте:

from modc import foo - не выполняется print.

Пакеты.

Пакет - катало, включающий в себя жр. пакеты и модули.
В нем есть файл __init__.py

new -> python package.

Назначение - формирование пространств имен.

Работа с модуляеми с указанием их вложенности.
пакет1.пакет2.модуль
Уровни вложенности отделяются точкой.

Импорт пакета внутри пакета из одного модуля в другой:

import.модуль

import пакет.модуль - если в другом пакете  или в этом же (стандартно).

import, from, as..

Например:

from .doctors.surgeons import get_surgeons

# в текущем пакете есть еще пакет докторс, в нем модуль surgeons, из которого мы
импортируем функцию get_surgeons.

Модули os и sys

OS

функции для работы с ОС, не зависят от конкретной ОС.

name - имя ОС
chdir - смена директории.
getcwd() - текущая рабочая директория
mkdir() - создание папки
os.path - модуль для работы с путями и др.
os.rmdir(path, *, dir_fd=None) - удаляет пустую директорию.


import os

print(os.name)

new_path = os.path.join(os.getcwd(), 'new_f') #создаем путь
os.mkdir(new_path) #создаем папку по этому пути

Модуль SYS

Взаимодействие с интерпретатором Python

executable - путь к интерпретатору.
exit() - выход из Питона
platform - инф. об ОС.
path - список путей поиска модулей.
argv - список агрументов комендной строки.
и др.

Sys.path

Хранит пути, по которым Питон будет искать модули, содержит list.

Добавляем новый путь в переменную sys.path:

sys.path.append('D:')
# после чего уже можем импортировать наш модуль с диска D:
import mymodule

for i in range(1, 6): # цикл из 5 повторений

sys.argv

список агрументов комендной строки при запуске скрипта python.
sys.argv[0] - путь до нашего скрипта (это последняя часть пути до файла скрипта).
остальные параметры передаются через пробел:
python my_script.py par1 par2 par3..

Командная строка: (запуск скрипта!)
View -> tool windows -> terminal

# все параметры передаются как str

Получаем первый параметр (2й по порядку):

import sys

command = sys.argv[1]

Далее обрабатываем его..

Работа с файлами.

Функция open:

Открывает файл в указанном режиме.
f = open('my.txt', 'w')
параметры:
file
mode
encoding

Mode:
r - чтение
w - запись, если недоступен, то создается новый файл.
x - запись, если недоступен, то ошибка.
a - дозапись
b - двойной режим
+ - открытие на чтение и запись одновременно.

Запись текста в файл:

write - строка в файл.
writelines - записать список строк в файл.
\n -  перенос строки.

f = open('first.txt', 'w')

f.write('Hello\n')
f.write('World!')

f.writelines(['Hello\n', 'Python!'])

Чтение из файла:

read - чтение файла целиком
for line in f: чтение файла построчно
readlines - чтение файла в список строк.

f = open('first.txt', 'r')

print(f.read())

for line in f:
	print(line.replace('\n', '')) # заменяем в файла символы \n на пустое место.

print(f.readlines())

--> список из строчек.

Закрытие файла.

Файлы нужно закрывать, иначе они тратят ресурсы.

- f.close() # однако, если до close произойдет исключительная ситуация, то файл
не будет закрыт.

- Конструкция with	

f = open('first.txt', 'r')

f.close()

или же

with open('first.txt', 'r') as f:
	 for line in f:
	     	print(line('\n', ''))
			
# далее файл сам закрывается по окончании блока with.

Строки байт.

Типы строк:

str - обычные строки
bytes - строки байт
bytearray - изменяемая строка байт

sb = b'Hello world'
type - bytes

--> b'Hello world

Действия со строками байт:

индекс sb[0]
срез sb[1:3] и др.

В обычной строке индекс строки - это символ, в строке байт - его код.

s = 'Hello world'
sb = b'Hello world'

print(s[1])

--> e  # s
--> 101 # sb

срез - отличие в букве b'

print(1:3)

--> el
--> b'el'

На самом деле во втором случае все равно коды, просто выводится красиво.
Проверить можно по типу - это bytes.

Как строка храрится в памяти.

Любая инф. хранится как набор 0 и 1, т.о. каждому символу в строке ставится
в соответствие его код, т.е. число.

Коды зависят от кодировки:

ascii - американская
latin-1 европейская
utf-8 - универсальная

Перевод строки в байты: 
Кодирование.

'Hello world'.encode('utf-8')

Декодирование.

sb.decode('utf-8')

Запись и чтение байтов.

Работа с файлом в режиме байтов.

open('filename','wb')
open('filename','rb')

with open ('bytes.txt', 'wb') as f:
	pass
	
with open ('bytes.txt', 'rb') as f:
	pass

# после этого мы читаем файл уже с указанием кодировки.
with open ('bytes.txt', 'r', encoding='utf-8') as f:
	pass

Запись байтов в файл:

f.write(b'some bytes') - файл открыт в режиме wb
f.write('some str') - в режиме w.

with open('bytes.txt', 'wb') as f:
	str = 'Привет мир'
	f.write(str.encode('utf-8'))
	
with open('bytes.txt', 'r', encoding='utf-8') as f:
	print(f.read())

--> Привет мир

Чтение байтов из файла.

f.read() - если в rb - читаем байты, если r - строки.

with open ('bytes.txt','rb') as f:
	result = f.read() #читаем байты
	print(result) # --> набой байт.
	print(type(result))
	s = result.decode('utf-8') #чтобы получить строку в читаемом виде, нужно декодировать
	print(s) --> Привет мир
	
# При этом писать можно как через wb, так и через w - все едино, данные храняться в виде байт.

Модуль Pickle.

Сериализация.

Процесс перевода объекта в поток байтов для сохранения или передачи в бд.

Способы записи объекта в файл:

ручной 
универсальный через pickle.

Пример ручного:

person = {'name': 'Max', 'phones': [123, 345]}

with open('person.dat', 'wb') as f:
	name = person['name']
	f.write(f'{name\n}'.encode('utf-8'))
	phones = person['phones']
	for phone in phones:
		f.write(f'{phone}\n'.encode('utf-8'))
		
# Записали!

Теперь читаем:

with open('person.dat', 'rb') as f:
	result - f.readlines()   #прочитали файл в список.

# воссоздаем исходный объект.

person={}

person['name'] = result[0].decode('utf-8').replace('\n', '')

phones = []

for bphone in result[1:]:
	phones.append(bphone.decode('utf-8').replace('\n', ''))

person['phones'] = phones

print(person)

Прочитали.

Надо помнить как мы делали сохранение.

Модуль pickle.

Сохраняет сложные объекты в файл, преобразует в байты.

dump - сохраняет в файл
dumps - объект в байты
load - загружает из файла
loads - загружает из набора байт

import pickle

person = {'name': 'Max', 'phones': [123, 345]}

with open('person.dat', 'wb') as f:
	pickle.dump(person, f) # сначала передаем объект, потом имя файла.
	# person = pickle.load(f) - читаем объект из файла.
	
# Записан!

Модуль Json.

JavaScript object notation.

Текстовый формат обмена данными. Аналогичен набору словарей, списков, но является просто строкой.
То есть словари, списки и т.д., но записанные в виде текста.

import json

Основные функции.

dump сохранение объекта в формате json в файл
dumps преобразование объекта в json (текст), без записи в файл.

load загрузка объекта из файла
loads загрузка объекта из формата json (строки)

json_friends = json.dumps(friends)

type - str.

При выводе его - объект практически не меняется (был словарь), но он становится
строкой.

Запись в файл:

Открываем файл через w, потом:

json_friends = json.dump(friends, f) #friends - список, который пишем, f - файл открыт как f.

загрузка:

friends = json.load(f)

Тернальный оператор.

Это операция, которая возвращает свой первый или третий операнд в зависимости
от значения логического выражения, заданного вторым операндом.

результат1 если выражение истинно и результат2, если иначе.

Применение вместо if.. else..
Компактнее.

Примеры:

name = 'Max' if is_has_name else 'Empty' # если условие is_has_name истинно, иначе..
number = 1 if is_one_ else 2
print('Привет' if is_russian else 'Hello')

is_has_name = True
name = 'Max' if is_has_name else 'Empty'
print(name)

--> Max

Если есть список, нам нужно сделать строку:

result = []
result.append(letter)
result = ''.join(result)

Генераторы списков.

Конструкции, которые позволяют по правилам создавать заполненные списки.

Генераторы применяются вместо for, работают быстрее, компактнее.

[number for number in numbers if number > 0]

result = [number for number in numbers if number > 0]
print(result)
# выбираем из списка числа, которые > 0.

Создаем словарь из кортежей:

pairs = [(1, 'a'), (2, 'b'), (3, 'c')]

result = {}

for pair in pairs:
	key = pair[0]
	val = pair[1]
	result[key] = val

print(result)

# или же через генератор:

result = {pair[0]: pair[1] for pair in pairs}
print(result)

Пример - список случайных чисел:

Условие if не обязательно:

import random

numbers = [random.randint(1, 100) for i in range(10)]
print(numbers)

Список из квадратов чисел:

numbers = [1,2,3,-4]

numbers = [number**2 for number in numbers]

print(numbers)

# список имен на букву А:

names = [name for name in names if name.startswith('A')]

Пример, комбинация генератора и тернального оператора:

result = [math.sqrt(number) if number > 0 else number for number in input_list]

math.sqrt(number) if number > 0 else number - тернальный оператор.

таким образом - если число в списке меньше нуля, то мы записываем его без изменений,
в противном случае - корень из него.



Принципы работы AND и OR:

Приведение типов к bool:

Все типы данных приводятся к bool по правилам:

Истина: 'abc', [1], (1,), {1: 'a'}, 10, 1.1, ...

Ложь: '', (), {}, 0, None, ...

Поэтому например вместо:

if len(str_var) > 0: ...

пишем:

if str_var: ...

т.к. сама не пустая строка является условием True, а пустая - False.

Как работает оператор and:

Не проверяет следующее логическое выражение если текущее False.
Возвращает первый ложный элемент или последний истинный.

Например: 

if 1 > 2 and math.sqrt(-1) # питон проверяет первое условие, оно ложь и 
не проверяет второе, поэтому программа не выдаст ошибку и выполняется далее.
При этом корень не будет вычисляться.
(квадратный корень из -1 выдал бы ошибку!)

if math.sqrt(-1) and 1 > 2 # ошибка!

Возвращается первая ложь:

print([1] and [2] and '' and 1)
--> '' - пустая строка, первая ложь.

print([1] and 1 and 20 and 1.1)
--> 1.1 - последняя истина.

OR работает также как AND, но наоборот.

Не проверяет следующее условие, если первое истинно.
Возвращает первый истинный элемент или последний ложный.
if 1 > 2 OR math.sqrt(-1)
не будет ошибки!

print(0 or [] or 8)
--> 8

print(0 or p[ or () or 0)

--> 0

Примеры применения.

for number in numbers:
	if number > 0 and math.sqrt(number) < 2:
		result.append(number)
# если number < 0, то первое условие ложно, второе не выдаст ошибку, но и не
выполнится, не выполнится и запись в result, программа просто пройдет дальше.

def add_to_list(input_list=None):
	input_list = input_list or []
	input_list.append(2)
	return input_list

add_to_list()

# если ф. вызывается без параметров, срабатывает последнее истинное
условие, то есть создается пустой список.
если же список заполнен, то первое условие истинное, or берет первое
истинное условие, то есть оставляет список как есть.

Модуль Copy.

Если переприсваиваем список в другую переменную a = b и меняем значение внутри
нового списка b[1], то значения внутри старого списка a[1] тоже меняются
т.к. ссылки на элементы списка остаются на своих местах в памяти и каждый
список использует одни и те же элементы.

Пример: 

a = [1,2,3]

b = a

b[1] = 100

print(a)
--> [1, 100, 3]
элемент изменился в а.

Если мы меняем список в функции, меняется и список вне нее.

numbers = [1,2,3]

def change_number_in_list(input_list):
	input_list[1] = 200

change_number_in_list(numbers)

print(numbers)

--> [1, 100, 3]

Если мы не хотим менять элементы списка, нужно его скопировать и работать
с копией.

создание среза my_list[:] # от начала и до конца
метод copy у самого списка

a = [1,2,3]

b = a[:]

b[1]= 200
print(a)
--> [1,2,3]

тоже самое:

b = a.copy()

# не работает, если есть вложенные списки, т.к. срез и копи копируют
только первую часть списка, а вложенность не учитывают:

a = [1,2,[1,2]]

если поменять b = a[:]

b[2][1] = 200, то поменятся и a

Модуль copy делает глубокое копирование списка:

import copy

a = [1,2, [1, 2]]

b = a.copy.deepcopy(a)

тут копируется полностью, включая все вложенные списки.

т.о. если менять b, то а не поменяется.

Пример: если в функции нам нужно работать с копией списка, чтобы 
основной список не менялся в ф. пишем:

input_list = input_list.copy()

далее работаем и сним и:

return input_list

Обработка исключений.

Исключительная ситуация - дальнейшие вычисления невозможны.

Например, деление на 0, чтение без доступа.

Есть встроенный встроенный механизм обработки исключений.

Блок с возможной искл. ситуацией кладем в блок try:
то, что будет выполняться при исключении кладем в блок except:

Пример:

number = int(input('Введите число: '))

try:
	result = 100/ number
	
except: 
	print('Деление на 0')
	
print('Конец')

Каждая исключительная ситуация имеет свой тип:

TypeError, ValueError, ..

Рекомендуется обрабатывать каждую ситуацию по своему.

number = int(input('Введите число: '))

try:
	result = 100/ number
	
except ZeroDivisionError: 
	print('Деление на 0')
except Exception:
	print('Неизвестная ошибка')
	
Можно получить информацию об исключении, сохранив его так:

except Исключение as e:

Тогда в переменную e будет сохранено исключение.

except ZeroDivisionError as e: 
	print('Деление на 0')
	print e

try - except - else - finally

try - блок где могут быть исключения
except - что делать при исключении
else - что делать если исключения не произошло
finally - выполняется всегда

Генерация исключений.

raise Expection('сообщение') # после данного сообщения дальше не идем.

raise ValueError('пояснение'), т.е. можем писать тип ошибки, которую сгенерили.

Практикум. Файловый менеджер.

import os

# создаем файл, записываем в него текст:

def create_file(name, text=None):
	with open(name, 'w', encoding='utf-8') as f:
		if text:
			f.write(text)

def create_folder(name):
	try:
		os.mkdir(name)
	except: FileExistError:     # обработка исключения - папка уже существует.
		print('Такая папка уже есть')

def get_list():    # показываем все папки и файлы в текущей директории
	print(os.listdir())

# вариант:

def get_list(folders_only=False):    # только папки
	result = os.listdir()
	if folders_only:
		result = [f for f in result if os.path.isdir(f)] # os.path.isdir(f) - является ли выдача папкой..
	print(result)


#----------------------------- обращение к функциям

if __name__ == '__main__':   # чтобы при импорте скрипта в др.ф. чтобы не выполнялся.

	create_file(text.dat, 'some text')
	create_folder('new_f')
	get_list(True) #только папки.

Удаление файла/папки.

def delete_file(name):
	if os.path.isdir(name):
		os.rmdir(name) # удаляет папки	
	else:
		os.remove(name) # удаляет файла

Копирование.

import shutil

def copy_file(name, new_name):
	if os.path.isdir(name):
		try:
			shutil.copytree(name, new_name)
		except: FileExistError:
			print('Такая папка уже есть')
	else:
		shutil.copy(name, new_name)

Запись о работе менеджера в файл:

import datetime

def save_info(message):
	current_time = datetime.datetime.now()  # записываем в файл дату/время
	result = f'(current_time) - (message)'
	#print(result)
	with open('log.txt', 'a', encoding='utf-8') as f:  # 'а' - режим дозаписи
		f.write(result + '\n')
		
	save_info('abc')
	
Изменение директории:
	
def change_dir(dir_name):
	if os.path.isdir(dir_name):
		os.chdir(dir_name)
		print('Директория изменена')
	else:
		print('Введенное имя не директория')
------------------------
Добавляем игру - в файле game:

1. создаем ф. без параметров - внутри код игры (game()).
2. импортируем в script - from game import game.
3. в файле со скриптом пишем:

elif command == 'game'
	game()

------------------------
Собираем все функции в скрипт:

Импорт функций:

->New file: core.py		

копируем сюда все ф.

->New file: main.py		

from core import create_file, create_folder, get_list, delete_file, copy_file, save_info

# будет скрипт с параметрами:

import sys

save_info('Старт')  #Информация о менеджере лог начала работы

command = sys.argv[1]

if command == 'list':
	get_list()
elif command == 'create_file':

	try:
		name = sys.argv[2]
	except IndexError:
		print('Нет названия файла')
	else:
		create_file(name)
elif command == 'create_folder':
	name = sys.argv[2]
	create_folder(name)
elif command == 'delete':
	name = sys.argv[2]
	delete_file(name)
elif command == 'copy':
	name = sys.argv[2]
	new_name = sys.argv[3]
	copy_file(name, new_name)
elif command == 'help':
	print('list - список файлов и папок')
	print('create_folder')
	print('create_file')
	print('delete')
	print('copy')

save_info('Конец')  #Информация о менеджере лог конца работы


Запускаем скрипт из консоли:

-> python main.py help
-> python main.py create_file test.txt


Введение в GIT.

Командная строка:
cmd в поиске, powershell
bash - перейти в unix подсистему.

параметры команды: ls -l через "-"

pwd - точный путь к тому рабочему каталогу, в котором находишься сейчас.

cd - сменить каталог

touch hello.txt - создать файл

unix: ls -la / dir - windows

mkdir test - создать каталог

echo 'Hello world!' высести что-то в консоль

echo 'Hello world!' > hello.txt - записали в файл, перезатирая файл.

cat hello.txt - прочитали файл / type - в виндовс.

echo 'Hello world!' >> hello.txt - дозаписать в файл после того что там есть.

unlink hello.txt удалить файл

Путь к файлу:

Абсолютные пути:
В unix разделитель /
/var/home/www/htdocs/text.txt
/ - первый корневой раздел, он всегда один

Относительный путь:

../hello.txt
.. - родительский каталог.
. - текущий каталог

В win - \
C:\www\htdocs\text.txt
C:\ первый - диск, может быть несколько

Относительные, относительно www:
htdocs/text.txt 
htdocs\text.txt

Клиент GIT.

git --version - сначала идет указание на обращение к GIT, затем команда.

Сначала - представляемся системе, затем система даст править что-то.

git config --global user.name "Oleg Razumov"
git config --global user.email "elessar_2004@list.ru"

git config --list

убедились что ввесли изменения

git config --list --show-origin

где хранятся настройки, в обычном текстовом файле. его можно открыть и
отредактировать в любом редакторе.

Гит следит за состоянием некоторой папки, ее нужно поменить как гит
проект.

Пометим ее:

git init - пометить новую папку

git clone - загрузить сущ. проект из удаленного git-репозитория

oleg@MSI:/mnt/c/Users/eless/test$ git init  перешли в папку и пометили ее.

создалась папка .git в ней несколько подпапок и файлов.

oleg@MSI:/mnt/c/Users/eless/test$ ls -la
total 0
drwxrwxrwx 1 oleg oleg 4096 Jan 14 13:35 .
drwxrwxrwx 1 oleg oleg 4096 Jan 14 13:15 ..
drwxrwxrwx 1 oleg oleg 4096 Jan 14 13:33 .git
-rwxrwxrwx 1 oleg oleg    0 Jan 14 13:35 hello.txt
oleg@MSI:/mnt/c/Users/eless/test$ git add .   "." - все новый файлы в папке.
проиндексировали новый файл hello.txt под контроль GIT.
или же:
oleg@MSI:/mnt/c/Users/eless/test$ git add hello.txt 

Зафиксируем файл: создаем commit.

oleg@MSI:/mnt/c/Users/eless/test$ git commit -m 'Первый коммит' 

Если ввести без коммента, то перейдем в тектовый редактор по умолч.
наж esc + i и набираем коммент.

esc + : переходим в коммандный режим.
далее wq
Это если VIM
Если NANO: ctrl + o, cntrl + x записать и выйти.

git config --global core.editor notepad задаем редактор по умолчанию.

Загрузить другой репозиторий:

git clone https://github.com/..../dictionary.got dict

dict - новое имя папки после загрузки.

sudo apt update
sudo apt install git-gui

инсталляция git gui

!!! проблема!!

Файлы в гит проекте могут быть: отслеживаемые/неотслеживаемые.

Отслеживаемые - зарегистрированы в гит.
Затем файл нужно индексировать (git add), только индексированные файлы входят в commit.
После git commit файлы превращаются в снимок системы, а индекс снова обнуляется.

1. Завели новый файл, смотрим:

oleg@MSI:/mnt/c/Users/eless/test$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        readme.txt

nothing added to commit but untracked files present (use "git add" to track)

Файл помечен как неотслеживаемый.

Поменяли файл hello.txt:

oleg@MSI:/mnt/c/Users/eless/test$ git status
On branch master
Changes not staged for commit:    <---- тут отмечены что есть изменения,т.к. он отслеживаемый.
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   hello.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        readme.txt

no changes added to commit (use "git add" and/or "git commit -a")

Более короткий вывод:

oleg@MSI:/mnt/c/Users/eless/test$ git status -s
 M hello.txt
?? readme.txt

Смотрим изменения по файлу, который отслеживается:

oleg@MSI:/mnt/c/Users/eless/test$ git diff
diff --git a/hello.txt b/hello.txt
index 5dd01c1..fcf4117 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1 +1,2 @@
-Hello, world!
\ No newline at end of file
+Hello, world!^M
+новая строка
\ No newline at end of file

oleg@MSI:/mnt/c/Users/eless/test$ git add .  добавили файлы в индекс
oleg@MSI:/mnt/c/Users/eless/test$ git status оба вайла отслеживаются
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   hello.txt
        new file:   readme.txt

oleg@MSI:/mnt/c/Users/eless/test$ git diff  разницы нет, т.к. все в индексе
oleg@MSI:/mnt/c/Users/eless/test$  

Но что же попадет в коммит:

oleg@MSI:/mnt/c/Users/eless/test$ git diff --cached
diff --git a/hello.txt b/hello.txt
index 5dd01c1..fcf4117 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1 +1,2 @@
-Hello, world!     <-- красный, что удалили
\ No newline at end of file
+Hello, world!^M   <-- зеленый, что новое
+новая строка
\ No newline at end of file
diff --git a/readme.txt b/readme.txt
new file mode 100644
index 0000000..0e30505
--- /dev/null
+++ b/readme.txt
@@ -0,0 +1 @@
+Новый проект
\ No newline at end of file

Сразу git add и got commit одной коммандой:

oleg@MSI:/mnt/c/Users/eless/test$ git commit -am 'Измениния'
[master 53149a6] Измениния
 2 files changed, 3 insertions(+), 2 deletions(-)

Удаление файлов.

Если файл не отслеживаемый, мы просто его удаляем:

unlink to_delete.txt

Если же он отслеживаемый, можно откатить последние изменения:

git checkout -- hello.txt

Если же файл был проиндексирован:

1. Переводим в неиндексированное состояние:
git reset HEAD hello.txt

2. git checkout -- hello.txt

История проекта.

git log

История коммитов. Просмотр пробелами. выйти - q

git log -2  2 последних коммита.

commit 4b5c1b8b40352dc1f4417d81fae60ba2d3aafe69   <-- это хэш
Author: Oleg Razumov <elessar_2004@list.ru>
Date:   Tue Jan 14 15:15:53 2020 +0300

git log -2 -p

содержание коммитов.

git log -2 --stat

статистика коммитов.

commit 53149a68069231c61daee9e7be3190e2ba7db9a1 (HEAD -> master)
Author: Oleg Razumov <elessar_2004@list.ru>
Date:   Tue Jan 14 15:17:47 2020 +0300

    Измениния

 hello.txt  | 2 +-
 readme.txt | 3 ++-
 2 files changed, 3 insertions(+), 2 deletions(-)
 
 сколько было изменений.
 
 git log --pretty=oneline
 
 53149a68069231c61daee9e7be3190e2ba7db9a1 (HEAD -> master) Измениния
4b5c1b8b40352dc1f4417d81fae60ba2d3aafe69 комментарий2
c203bb4c0c8d7d783b8203390887d78dfa09fe08 комментарий1
2780d8a6d00ea71aefda618260a17a0644305f65 comment1^M# Please enter the commit message for your changes. Lines starting^M# with '#' will be ignored, and an empty message aborts the commit.^M#^M# On branch master^M# Changes to be committed:^M#        modified:   hello.txt^M#
1fc5523b059f8d679f66b2f08305992c61ae8243 Первый коммит

хэши и комментарии к коммитам.

git log --pretty=format:"%h - %an, %ar : %s"

можно самому задавать формат.

Хэш сумма коммита:

Механизм К1.

Вычисляется на основе содержимого файла или структуры каталога.

По этой сумме гит определяет изменения.

При обращении по хэшу, можно его сократить до того количества символов,
когда он еще отличается от других.
7-8 символов.

git log --since=2.week  2 недели назад
git log --until=1.week  1 неделя с начала проекта

Поиск логов в промежутке:
git log --since=2019-03-01 --until=2019-03-25

git log -SGit -p

Коммиты, в которых упоминается слово GIT

git log --author="Oleg Razumov"

Коммиты только этого автора

git blame hello.txt

Кто автор определенных строк:

oleg@MSI:/mnt/c/Users/eless/test$ git blame hello.txt
c203bb4c (Oleg Razumov 2020-01-14 15:13:47 +0300 1) Hello, world!
4b5c1b8b (Oleg Razumov 2020-01-14 15:15:53 +0300 2) новая строка
53149a68 (Oleg Razumov 2020-01-14 15:17:47 +0300 3) ввйцайцм

Все что попадает в репозиторий, клонируется вместе с ним и не удаляется
из истории даже если файл был удален.

Если его нужно удалить:

В корень проекта помещается файл:
.gitignore

В файле:

*.log
tmp/

Это игнорит все файлы с расширением log и файлы в папке tmp/

http://gitignore.io/

На основе ключевых слов делает файл .gitignore

Git ориентируется на файлы, пустые папки гит игнорит.

Если нужно чтобы папка попала в индекс:
добавляем в папку файл:
.keep

пустой. Тогда гит видит эту папку.

Ветки.

Ветка - хронологическая последовательность коммитов.

oleg@MSI:/mnt/c/Users/eless/test$ git branch
* master

показывает в какой ветке мы сейчас.

oleg@MSI:/mnt/c/Users/eless/test$ git branch feature
oleg@MSI:/mnt/c/Users/eless/test$ git branch
  feature
* master

Создали новую ветку.

oleg@MSI:/mnt/c/Users/eless/test$ git checkout feature
Switched to branch 'feature'
oleg@MSI:/mnt/c/Users/eless/test$ git branch
* feature
  master
oleg@MSI:/mnt/c/Users/eless/test$   

переключились на другую ветку.

git checkout -b feature

создали и сразу переключились.

oleg@MSI:/mnt/c/Users/eless/test$ git branch -m feature to_delete

Переименовали ветку.

!!! Удаляем ветку!!

oleg@MSI:/mnt/c/Users/eless/test$ git branch -D to_delete
Deleted branch to_delete (was 53149a6).

Удаляем ветку, но нужно переключиться на другую, если на ней.

Создали новый файл и закоммитили его под новой веткой, переключившись на нее, смотрим лог:

oleg@MSI:/mnt/c/Users/eless/test$ git log --pretty=format:"%h -%d %s %cd" --graph
* d3a49ea - (HEAD -> test) Новая ветка Thu Jan 16 11:16:23 2020 +0300
* 53149a6 - (master) Измениния Tue Jan 14 15:17:47 2020 +0300
* 4b5c1b8 - комментарий2 Tue Jan 14 15:15:53 2020 +0300
* c203bb4 - комментарий1 Tue Jan 14 15:13:47 2020 +0300
* 2780d8a - comment1^M# Please enter the commit message for your changes. Lines starting^M# with '#' will be ignored, and an empty message aborts the commit.^M#^M# On branch master^M# Changes to be committed:^M#     modified:   hello.txt^M# Tue Jan 14 13:39:13 2020 +0300
* 1fc5523 - Первый коммит Tue Jan 14 13:38:31 2020 +0300

Видим что последний коммит в ветке test.

Слияние:

git merge. В момент слияния мы должны находится в ветке куда будем сливать
изменения.

Сделали слияние:
oleg@MSI:/mnt/c/Users/eless/test$ git merge test  !! тут та ветка, которую сливаем.
Merge made by the 'recursive' strategy.
 branch.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 branch.txt

Отрисованный график веток, которые слились:

oleg@MSI:/mnt/c/Users/eless/test$ git log --pretty=format:"%h -%d %s %cd" --graph
*   adce7a7 - (HEAD -> master) Merge branch 'test' Thu Jan 16 11:21:33 2020 +0300
|\
| * d3a49ea - (test) Новая ветка Thu Jan 16 11:16:23 2020 +0300
* | 4662695 - Новый файл в главной ветке Thu Jan 16 11:20:57 2020 +0300
|/
* 53149a6 - Измениния Tue Jan 14 15:17:47 2020 +0300
* 4b5c1b8 - комментарий2 Tue Jan 14 15:15:53 2020 +0300
* c203bb4 - комментарий1 Tue Jan 14 15:13:47 2020 +0300
* 2780d8a - comment1^M# Please enter the commit message for your changes. Lines starting^M# with '#' will be ignored, and an empty message aborts the commit.^M#^M# On branch master^M# Changes to be committed:^M#     modified:   hello.txt^M# Tue Jan 14 13:39:13 2020 +0300
* 1fc5523 - Первый коммит Tue Jan 14 13:38:31 2020 +0300

Псевдонимы комманд Alias:

oleg@MSI:/mnt/c/Users/eless/test$ git config alias.gg 'log --pretty=format:"%C(yellow)%h%Creset"' 

Назначили псевдоним gg для команды в кавычках.

Команда теперь вызывается: git gg

Разрешение конфликтов:

Если мы сделали два коммита с одним и тем же файлом, но разным его 
содержанием из под разных веток, а потом их сливаем, будет конфликт.

CONFLICT (add/add): Merge conflict in hello.php  <-- указан файл с проблемой.

Чтобы его разрешить, нужно открыть файл, где две версии конфликтующие между
собой будут отделены:

<<<<<<<<<< HEAD
...
===============================
...
>>>>>>>>>> test

Две ветки HEAD и test.

Чтобы разрешить конфликт, удаляем одну из версий или пишем новую в файле и
сохраняем.

Снова индекс и коммит, все ок.

Создание удаленного GIT репозитория.

Чтобы изменения созданные на вашем компьютере стали доступны другим, их
необходимо отправить на удаленный гит хостинг.
И загрузить изменения с него.

Удаленный гит репозиторий это коипьютер с гит.

Самые известные хостинги:

GitHub
BitBucket
GitLab

Или можно развернуть свой хостинг на сервере с SSH доступом.

https://github.com/

Популярный бесплатный хостинг.

Платный хостинг только если проект закрывается от других.

На сейте регистрация, затем на иконку пользователя - Settings, SSH and GPG keys
Add new SSH.

Новый проект: в верхнем меню + и new repository.

Хотим загрузить наш репозиторий:

or push an existing repository from the command line
git remote add origin https://github.com/Orazumov/hello.git  <-- копируем эту строку

oleg@MSI:/mnt/c/Users/eless/test$ git remote add origin git@github.com:Orazumov/hello.git
														всегда git!		путь к репозиторию



git remote rm origin удалить если неправильно ввел!


git push -u origin master

Отправляем репозиторий на сервер.

Регистрация удаленного сервера .git/config

git remote add origin

в файле config появляется секция:

[remote "origin"]
	url = ...
	fetch = ...
	
добавляем псевдоник для удаленного гит репозитория:

git remote add github git@github.com:Orazumov/hello.git
(псевдоним github)

Отправляем изменения в репозиторий:

git push github master
		уд. репозиторй ветка

git remote - список удаленных репозиториев.

git clone https://github.com/VictoriaMetrics/VictoriaMetrics victoria

клонируем удаленный репозиторий.

Если кто-то изменил удаленный репозиторий, а мы пытаемся сделать push,
git выдаст ошибку и попросит сначала загрузить то, что изменилось с уд.
репозитория.

Делаем так:

git pull origin master - скачиваем изменения с уд. репозитория.

После этого делаем push как указано выше, проходит.

git fetch - загружаем все ветки с удаленного сервера, git pull загружает одну ветку.

Удаленные ветки.

Ветка на удаленном репозитории.

oleg@MSI:/mnt/c/Users/eless/test2$ git checkout -b fix_error
Switched to a new branch 'fix_error'

Создали новую ветку на локальной машине.

oleg@MSI:/mnt/c/Users/eless/test$ git branch
* fix_error
  master
  test
  
Изменения на локальной машине не отразяться на удаленной, пока мы не 
отправим изменения на сервер.

oleg@MSI:/mnt/c/Users/eless/test$ git branch -r

смотрим удаленные ветки.

git push origin fix_error <-- отправили ветку fix_error в уд. репозиторий origin

Если мы переименуем локальную ветку:

oleg@MSI:/mnt/c/Users/eless/test$ git branch -m fix_error to_delete
oleg@MSI:/mnt/c/Users/eless/test$ git branch
  master
  test
* to_delete

изменения будут только локальные, удаленная ветка не поменяется.

Если мы ее отправим на сервер, то на нем будет новая ветка to_delete.

При удалении локальной ветки, удаленная останется.

Удаляем ветку на сервере:

git push origin :to_delete
(! двоеточие перед именем ветки)

Переименовываем удаленную ветку.

Для этого сначала создаем ее копию:

git brach to_delete origin/fix_error

появилась локальная ветка to_delete

Забрасываем ее на сервер:

git push origin to_delete

она появилась удаленно.

Далее удаляем старую удаленную ветку:

git push origin :fix_error

т.о. удаленная ветка переименована.

Чтобы постоянно не нажимать git branch чтобы увидеть в какой мы сейчас
ветке, можно клонировать проект, который выводит подсказку:

oleg@MSI:/mnt/c/Users/eless/test$ cd ~
oleg@MSI:~$ mkdir .bash создаем директорию
oleg@MSI:~$ cd .bash
oleg@MSI:~/.bash$ git clone https://github.com/jimeh/git-aware-prompt.git   клонируем в нее https проект с github
Cloning into 'git-aware-prompt'...
remote: Enumerating objects: 172, done.
remote: Total 172 (delta 0), reused 0 (delta 0), pack-reused 172
Receiving objects: 100% (172/172), 38.74 KiB | 450.00 KiB/s, done.
Resolving deltas: 100% (80/80), done.

Вносим изменения /.bash/profile

source "~/.bash/git-aware-prompt/main.sh
export PS1="\w \[\$txtcyn\]\$git_branch\[\$txtred\]\$git_dirty\[\$txtrst\]\$ "

НО ЭТО НЕ РАБОТАЕТ.

Если мы работаем в одной ветке, потом без коммита переходим в другую, то незафикс
изменения перейдут в новую ветку.

Чтобы этого не было, нужно выполнить команду git commit или:

Откладываем изменения на потом:
В старой ветке:
1. Добавляем их в индекс: git add .
2. git stash

Изменения не потеряны, а спрятаны в stash списке, смотрим их с помощью:

git stash list

oleg@MSI:/mnt/c/Users/eless/test$ git add .
oleg@MSI:/mnt/c/Users/eless/test$ git stash
Saved working directory and index state WIP on to_delete: adce7a7 Merge branch 'test'
oleg@MSI:/mnt/c/Users/eless/test$ git stash list
stash@{0}: WIP on to_delete: adce7a7 Merge branch 'test'
oleg@MSI:/mnt/c/Users/eless/test$     

Работаем в другой ветке, потом переключаемся обратно:

Смотрим:

oleg@MSI:/mnt/c/Users/eless/test$ git stash list
stash@{0}: WIP on to_delete: adce7a7 Merge branch 'test'

Затем применяем их из списка:

oleg@MSI:/mnt/c/Users/eless/test$ git stash apply
On branch to_delete
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   branch.txt
        modified:   hello.txt

no changes added to commit (use "git add" and/or "git commit -a")

Можно явно указать номер стэш метки:

git stash apply stash@{1} Если их несколько.

Изменения снова доступны для работы.

Удалить все из списка: git stash drop

oleg@MSI:/mnt/c/Users/eless/test$ git stash drop
Dropped refs/stash@{0} (ee08f589f96edcaefd83c2d0f008a529bc080b2b)

Версионирование.

Версия состоит из 3х цифр:

1.4.0

1 - мажорная. меняется редко.
4 - минорная. регулярно с выходом новых релизов.
0 - патч. закрываются уязвимости.

Для пометки коммитов, есть механизм тэгов, меток.

Каждый коммит отличается хэшом, но можно поставить в соответствие тэг, короткое
запоминающиеся название.

oleg@MSI:/mnt/c/Users/eless/test$ git tag v1.3.0

Создаем тэг.

Даем тэгу название:

oleg@MSI:/mnt/c/Users/eless/test$ git tag -a v1.4.0 -m 'Новый тэг'

Смотрим доступные тэги:

oleg@MSI:/mnt/c/Users/eless/test$ git tag
v1.3.0
v1.4.0

Поиска по шаблону:

oleg@MSI:/mnt/c/Users/eless/test$ git tag -l v1.4*
v1.4.0

Удалили тэг:

oleg@MSI:/mnt/c/Users/eless/test$ git tag -d v1.4.0
Deleted tag 'v1.4.0' (was c60eb58)

Смотрим описание тэга:

oleg@MSI:/mnt/c/Users/eless/test$ git show v1.3.0
commit adce7a7f1702da6a9b3f866d6d52f777ba5850db (HEAD -> to_delete, tag: v1.3.0, master)
Merge: 4662695 d3a49ea
Author: Oleg Razumov <elessar_2004@list.ru>
Date:   Thu Jan 16 11:21:33 2020 +0300

    Merge branch 'test'

Можно также смотреть по хэшу:

oleg@MSI:/mnt/c/Users/eless/test$ git show adce7a
commit adce7a7f1702da6a9b3f866d6d52f777ba5850db (HEAD -> to_delete, tag: v1.3.0, master)
Merge: 4662695 d3a49ea
Author: Oleg Razumov <elessar_2004@list.ru>
Date:   Thu Jan 16 11:21:33 2020 +0300

    Merge branch 'test'

Есть несколько доп. тэгом, один из них:

HEAD - последний коммит.

oleg@MSI:/mnt/c/Users/eless/test$ git show HEAD
commit adce7a7f1702da6a9b3f866d6d52f777ba5850db (HEAD -> to_delete, tag: v1.3.0, master)
Merge: 4662695 d3a49ea
Author: Oleg Razumov <elessar_2004@list.ru>
Date:   Thu Jan 16 11:21:33 2020 +0300

    Merge branch 'test'

Ставим тэг не на последний, а на произвольный коммит:

oleg@MSI:/mnt/c/Users/eless/test$ git tag -a v1.2.0 -m 'Старая версия' c203bb4

Добавлен:

* c203bb4 - (tag: v1.2.0) комментарий1 Tue Jan 14 15:13:47 2020 +0300

Отпачковываемся в новую ветку:

git checkout -b old_version_of_project v1.2.0

oleg@MSI:/mnt/c/Users/eless/test$ git checkout -b old_version_of_project v1.2.0
Switched to a new branch 'old_version_of_project'

Смотрим:

oleg@MSI:/mnt/c/Users/eless/test$ git log --pretty=format:"%h -%d %s %cd" --graph
* c203bb4 - (HEAD -> old_version_of_project, tag: v1.2.0) комментарий1 Tue Jan 14 15:13:47 2020 +0300
* 2780d8a - comment1^M# Please enter the commit message for your changes. Lines starting^M# with '#' will be ignored, and an empty message aborts the commit.^M#^M# On branch master^M# Changes to be committed:^M#     modified:   hello.txt^M# Tue Jan 14 13:39:13 2020 +0300
* 1fc5523 - Первый коммит Tue Jan 14 13:38:31 2020 +0300

То есть в новой ветке наш коммит с тэгом и старше него.

Чтобы отправить на сервер определенный коммит с тэгом:

git push origin v1.2.0

Если нужно отправить все тэги:

git push origin --tags

Запрашиваем все тэги на серваке:

git ls-remote --tags origin

Удаляем тэг с удаленного сервака:

git push origin :v1.2.0

Слияние веток и переносы.

Слияние изменений.

Пусть мы отпачковали новую ветку feature от master и нам нужно в дальнейшем ее слить обратно.
К тому времени обе ветки изменинились.

Отпочковываем: git checkout -b feature

Закидываем на сервер: git push origin feature

Изменяем один из файлов. Затем:

oleg@MSI:/mnt/c/Users/eless/test$ git add .
oleg@MSI:/mnt/c/Users/eless/test$ git commit -m "Adding new branch feature"
[feature 9bc0581] Adding new branch feature
 1 file changed, 3 insertions(+), 1 deletion(-)
 
Это все в ветке feature.

Переключаемся на мастер:

oleg@MSI:/mnt/c/Users/eless/test$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

Меняем один из файлов и делаем коммит, но в ветке мастер:

oleg@MSI:/mnt/c/Users/eless/test$ git add .
oleg@MSI:/mnt/c/Users/eless/test$ git commit -m "Adding new branch master"
[master 6532e4a] Adding new branch master
 1 file changed, 3 insertions(+), 1 deletion(-)
oleg@MSI:/mnt/c/Users/eless/test$

Теперь мы должны слить эти 2 ветки.

Самое простое: мерджим мастер c фича:

oleg@MSI:/mnt/c/Users/eless/test$ git checkout feature
Switched to branch 'feature'
Your branch is ahead of 'origin/feature' by 9 commits.
  (use "git push" to publish your local commits)
oleg@MSI:/mnt/c/Users/eless/test$ git merge master
Merge made by the 'recursive' strategy.
 master.txt | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
oleg@MSI:/mnt/c/Users/eless/test$

Второй вариант - перемещение ветки фича в гит истории таким образом
чтобы она снова начиналась с ветки мастер с последнего коммита.

Удобнее потом читать, т.к. последовательность будет более/менее линейная.

Переключаемся в ветку feature:

oleg@MSI:/mnt/c/Users/eless/test$ git rebase master

Теперь в feature присутствуют все изменения из ветки master.

Перевод одного или нескольких коммитов из одной ветки в другую.

Для этого есть комманда: cherry-pick:

oleg@MSI:/mnt/c/Users/eless/test$ git log --pretty=format:"%h -%d %s %cd" --graph
* 9d4a266 - (HEAD -> feature) cherry-pick1 Sun Jan 19 19:48:25 2020 +0300
* aa69df5 - Adding changes feature rebase1 Sun Jan 19 19:37:12 2020 +0300
* 9c4af23 - Adding changes feature rebase1 Sun Jan 19 19:37:12 2020 +0300
* d12b7a4 - Adding new branch feature Sun Jan 19 19:37:06 2020 +0300
* 5a49689 - Adding changes feature rebase1 Sun Jan 19 19:35:48 2020 +0300

берем хэш последнего коммита в нашей ветке, переключаемся в другую ветку:
(команда всегда выполняется в той ветке, куда мы переносим коммит)

oleg@MSI:/mnt/c/Users/eless/test$ git cherry-pick 9d4a266
[master 8ac2007] cherry-pick1
 Date: Sun Jan 19 19:48:25 2020 +0300
 1 file changed, 3 insertions(+), 1 deletion(-)
 
 перенесли!
 
 oleg@MSI:/mnt/c/Users/eless/test$ git log --pretty=format:"%h -%d %s %cd" --graph
* 8ac2007 - (HEAD -> master) cherry-pick1 Sun Jan 19 19:51:09 2020 +0300
* d5aa905 - Adding changes feature rebase1 Sun Jan 19 19:40:25 2020 +0300
* 8e6472f - Adding changes master rebase1 Sun Jan 19 19:28:15 2020 +0300

хэш изменился.

Если в процессе возникает конфликт:

1. Устраяем его в файле.
2. Добавляем в индекс (git add .)
3. Даем команду завершить cherry-pick:

git cherry-pick 9d4a266 --continue

Возможно объединить несколько коммитов в один и затем его перенести в другую
ветку, чтобы не переносить много коммитов по очереди.

Делаем еще коммиты в ветке фича.

Смотрим насколько ветка фича отличается от мастера:

oleg@MSI:/mnt/c/Users/eless/test$ git cherry -v master
+ 5a496892f22e79b685bca6970cd07bc3dc6378c4 Adding changes feature rebase1
+ d12b7a44e23570b55196075ac8d24cbdf9d4cd79 Adding new branch feature
+ 9c4af2398c275611b0263cff43ad3fedacd7d441 Adding changes feature rebase1
+ aa69df51e3c5936fae84fc4aa80d9fd6b1ec402d Adding changes feature rebase1
- 9d4a266abc94c508ec3aa47ccd1caf9888a167a1 cherry-pick1
+ 4ee1d56b1c22f8adc715a71ccab0db41343bb342 squash

Смотрим последний коммит с помощью тэга по умолчанию HEAD, а также 
коммит перед ним через HEAD~1:

oleg@MSI:/mnt/c/Users/eless/test$ git show HEAD
commit 4ee1d56b1c22f8adc715a71ccab0db41343bb342 (HEAD -> feature)
Author: Oleg Razumov <elessar_2004@list.ru>
Date:   Sun Jan 19 19:55:55 2020 +0300

    squash

diff --git a/master.txt b/master.txt
index de27810..aea619f 100644
--- a/master.txt
+++ b/master.txt
@@ -3,4 +3,6 @@ fefew

 11

-22
\ No newline at end of file
+22^M
+^M
+hello squash!
\ No newline at end of file
oleg@MSI:/mnt/c/Users/eless/test$ git show HEAD~1
commit 9d4a266abc94c508ec3aa47ccd1caf9888a167a1
Author: Oleg Razumov <elessar_2004@list.ru>
Date:   Sun Jan 19 19:48:25 2020 +0300

    cherry-pick1

diff --git a/master.txt b/master.txt
index b06cb82..de27810 100644
--- a/master.txt
+++ b/master.txt
@@ -1,4 +1,6 @@
 master new
 fefew

-11
\ No newline at end of file
+11^M
+^M
+22
\ No newline at end of file
oleg@MSI:/mnt/c/Users/eless/test$ 

и т.д., HEAD~2, HEAD~3, ...

Объединяем несколько коммитов:

git rebase -i HEAD~3

Открывается файл:

pick 5a49689 Adding changes feature rebase1
pick d12b7a4 Adding new branch feature
pick 9c4af23 Adding changes feature rebase1
pick aa69df5 Adding changes feature rebase1
pick 9d4a266 cherry-pick1
pick 4ee1d56 squash

# Rebase 8e6472f..4ee1d56 onto 8e6472f (6 commands)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like "squash", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out


Если оставляем значение pick, то эти коммиты остаются как есть.
Если же squash, то объединяются.

Меняем:

pick 5a49689 Adding changes feature rebase1
squash d12b7a4 Adding new branch feature
squash 9c4af23 Adding changes feature rebase1
squash aa69df5 Adding changes feature rebase1
squash 9d4a266 cherry-pick1
squash 4ee1d56 squash

Оставляем как минимум один коммит как пик.

Предлагается сохранить описание для коммитов, оставляем как есть.

Сохраняем.

oleg@MSI:/mnt/c/Users/eless/test$ git rebase -i HEAD~6
[detached HEAD 4414797] Adding changes feature rebase1
 Date: Sun Jan 19 19:35:48 2020 +0300
 3 files changed, 7 insertions(+), 3 deletions(-)
Successfully rebased and updated refs/heads/feature.

Убедимся, что коммиты склеены:

oleg@MSI:/mnt/c/Users/eless/test$ git cherry -v master
+ 441479770437a9c78a18e069db8bf5ab843e47d5 Adding changes feature rebase1
oleg@MSI:/mnt/c/Users/eless/test$

Если при попытке загрузить ветку на сервер выдается ошибка, нужно перезаписать
эту ветку принудительно, т.к. на сервере хранится старая версия.

git push origin feature --force

Несколько коммитов объединены в один.

Gitflow:

Роли в проекте:

Разработчик, Тестировщик --- менеджер --- заказчик

Разработчик - Frontend, Backend

Менеджеры - Продакт, проджект

Эксплуатация (если есть своя инфраструктура).

Gitflow - набор правил ветвления, который позволяет управлять релизами проекта.

Постоянные ветки: master, develop. На всем протяжении проекта.

master - главная, код в ней всегда готов к релизу.
develop - для разработки, в ней последний разработанный код.
когда в этой ветке код стабилен и готов к релизу, из него код вливается
в ветку master.

Вспомогательные ветки задач:

1. Ветки задач feature (отпачковываются от develop для решения опред. задачи, заводится тикет на функционал, номер тикета указывается в описании к ветке).
2. Релизные ветки release (используется для подготовки к выпуску новых версий продукта, все задачи, которые будут в релизе и спокойно тестировать их, при это dev свободен для доп. работ по релизу).
(При сливании с мастер, меняется минорная версия: 2.4.1 -> 2.5.1)
3. Hot-fix ветки (предназначены для исправлений пост релизных, это небольшие и очевидные исправления).
(При сливании с мастер, меняется версия патча: 2.4.1 -> 2.4.2)

Идеально, когда под каждую ветку есть свое окружение.

SSH Secure Shell.

Clien SSH/Git client (также поддерживает SSH) <-> SSH Server

Шифрование, даже при перехвате, невозможно расшифровать.

Обрашение к серверу:

ssh 46.36.218.162
(в этом случае логин - имя пользователя).

whoami - показать имя

oleg@MSI:/mnt/c/Users/eless/test$ whoami
oleg

Чтобы постучаться с именем:

ssh root@46.36.218.162

После первого логина на сервер, запрашивается подтверждение, затем создается
папка на локальной машине:

/.ssh ls -la   
--> known_hosts

В файле IP адреса SSH серверов.

Можно давать команду сразу на сервер:

ssh root@46.36.218.162 uptime

соединение устанавливается только на время выполнения команды.

ssh root@46.36.218.162 "ls -la" <-- если есть пробелы, то кавычки

На одном хосте (с один IP адресом) может быть несколько серверов, они отличаются
портами. Для SSH сервера - 22 порт.

Но порт может меняться, в этом случае в команде его указываем тут:

ssh -p 2222 root@46.36.218.162

/.ssh/config <-- конфигурационный файл.

Тут можно создавать псевдонимы:

В файле есть имя, адрес хоста и порт, поэтому можно обращаться по имени (псевдониму).

ssh node1

В файле конфиг есть все, кроме пароля.
Поэтому есть доступ по открытому ключу, если нужно автоматизировать доступ.

Закрытый ключ - в домашнем компе, открытый - на сервере в папке:

/.ssh/authorized_keys

на локальной машине:

ssh-keygen -t rsa

Вопросы: 

1. Путь сохранения ключа.
2. Ввести пароль для закрытого ключа.
3. Повторите пароль.

В итоге создалось два ключа:

cd /home/oleg/.ssh

cd .. выход на уровень выше
 
/.ssh/id_rsa <-- закрытый ключ
/.ssh/id_rsa.pub <-- открытый ключ

-rw------- 1 oleg oleg 1766 Jan 16 18:51 id_rsa
-rw-r--r-- 1 oleg oleg  390 Jan 16 18:51 id_rsa.pub
oleg@MSI:~/.ssh$ cat id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCvMyPGYM7lO8W5Xt01DydtNoR677Hs+CSD4cxRFrUBu8HlnyKGlWuCL40ROqGDAsEmoit37sRVl5dFltRv6IVHS68msln2/AswPmfkaVSuHP8qrdjqN6bPzyyTiTCEXmiRFz252kV2ppLrgzM1Elga1DtWMW8SKAInMwWZ6Ie6NN4/3DeZlIgBWqu+WXblh9kgkb1uZXoYCn7a5QX4i9hjt4GrtLQWI6uZAKF0vPd6jCbeMbnu4ioaae02VguTWDdbtcBWtCrw8Ngwn//U24J5VaaKU0cyPGlVSYAALNiCSaxoUGqFM57DX7WP74lO22wUSWTm63QBJ90x0a/38aVH oleg@MSI

Открытый ключ отправляется на сервер и дописывается в файл конфиг.

Также его нужно записать в файл authorized_keys на сервере.

После чего можно попасть на сервер, не вводя пароль.

Но все равно запрашивается пароль для закрытого ключа. Чтобы каждый раз 
его не вводить, можно ввести команду:

ssh-add, затем ввести его. Теперь он запрашиваться не будет.

Для доступа по SSH есть граф. клиент Putty.
Для Putty нужен PuttyGen чтобы сделать ключ для доступа к серверу.

Домашняя работа.

Вся дз в обучении будет сдаваться через Git. 
Преподавателю отправляется результат сравнения разных веток/коммитов, которые
залиты на GitHub: Pull request, копируется hash в первый выпадающий список. Второй - это master/HEAD.

Преподавателю отправляется ссылка на результат выполнения pull request.

Под каждое из ДЗ создается отдельная ветка.

Она сливается на github, потом создается отдельный пул реюэст для сравнения двух веток, ссылка на который
отправляется преподавателю.



--------------------

Установка либы через конду:

Запускаем пайчарм под админом.

conda install pillow

activate base

python

import PIL


---------------------



Измеряем какая программа работает быстрее:

from time import time


ts1, ts2 = 0, 0
for _ in range(10000):
    ts1_d = time()
    l1 = [number for number_x in (20, 21) for number in range(number_x, 240, number_x)]
    ts1 += time() - ts1_d

    ts2_d = time()
    l2 = [number for number in range(20, 240, 1) if number % 20 == 0 or number % 21 == 0]
    ts2 += time() - ts2_d

print(ts1)
print(ts2)
можно увидеть, кто быстрее - но, наверно, есть  метод лучше


вот у меня есть стопка:

file        ____
file        ____
file        ____
file        ____
file        ____
я беру верхнюю папку, перекладываю, получаю

____  >|    ____
file   |    ____
file   |    ____
file   |    ____
file   |->  file
допустим, что код такой:

def move_right(left_stack, right.stack):
    # если есть файлы 
    # в левой стопке
    if left_stack: 
        # взяли верхний файл
        file = left_stack.pop()
        # поместили файл 
        # туда, куда нужно 
        right_stack.append(file)
как видно, ситуация, которая сложилась после перемещения, очень похожа на изначальную, а значит, что нам нужно опять применить нашу функцию. однако, и после перемещения ситуация опять будет требовать применения нашей функции (уже в третий раз):

____        ____
____  >|    ____
file   |    ____
file   |->  file
file        file
получается, что после первого вызова нашей функции нам нужно вызывать её некоторое количество раз. Остановиться мы должны ровно в тот момент, когда стопка опустеет. 

На данный момент (используем написанную функцию) мы можем сделать вот так:

while left_stack:
    move_right(left_stack, right_stack)
и это то, что нам нужно.

Но мы можем сделать "умную" функцию, которая будет брать верхний файл, если он есть, перемещать его, и снова брать верхний файл, если он есть, перемещать его, и снова брать верхний файл, если он есть, перемещать его, и снова брать верхний файл, если он есть, перемещать его, и снова брать верхний файл, если он есть, перемещать его, и снова ... (ясно, да? :>) до тех пор, пока стопка не опустеет (либо структура, подаваемая ей на вход не примет форму, с которой уже ничего ни сделать). 

просто переписываем код move_right:

def move_right(left_stack, right.stack):
    # если есть файлы 
    # в левой стопке
    if left_stack: 
        # взяли верхний файл
        file = left_stack.pop()
        # поместили файл 
        # туда, куда нужно 
        right_stack.append(file) 
        # идём дальше и 
        # повторяем всю операцию, 
        # но уже на измененной 
        # левой стопке
        move_right(left_stack, right_stack) 
     else:
         # если левая стопка 
         # опустела, мы ничего 
         # не делаем, т.е. ф-ия 
         # прекращает рекурсивно 
         # вызывать саму себя - 
         # ВСЯ работа сделана
         pass
стоит заметить, что случай у нас был простой, но если логика некоторой обработки по-сложнее, то мы можем легко спрятать многократный "вызов функции в цикле" внутри самой функции, сделав её рекурсивной.

"перенести все файлы" стало одной простой операцией в коде - теперь для разработчика это "элементарная" (единичная) операция, суть простая для применения функция, которая делает полноценную работу

--------------------------

sorted(array, key = abs)
отсортировать по абсолютному значению, при этом на выходе часть чисел так и будет с минусом.

--------------------------


def bigger_price(limit: int, data: list) -> list:
    return sorted(data,key=lambda item : item["price"],reverse=True)[:limit]
	
пример использования key - сортировка по параметру словаря price.

assert bigger_price(2, [
        {"name": "bread", "price": 100},
        {"name": "wine", "price": 138},
        {"name": "meat", "price": 15},
        {"name": "water", "price": 1}
    ]) == [
        {"name": "wine", "price": 138},
        {"name": "bread", "price": 100}
    ], "First"
	
это задача - нужно отсортировать ТОП из списка словарей.



========================================================



Функция filter() - фильтрация последовательностей

 
В языке программирования Python есть встроенная функция filter(), которая принимает два параметра и возвращает объект-итератор. Первый аргумент этой функции - какая-либо другая функция, а второй - последовательность (строки, списки и кортежи), итератор или объект, поддерживающий итерацию.

Функция filter() возвращает итератор, состоящий из тех элементов последовательности, для которых переданная в качестве первого аргумента функция вернула истину (true) или ее аналог (не ноль, не пустую строку, не None).

В примере ниже создается функция func(), которая возвращает 1, если ей передан аргумент больше нуля, и 0 во всех остальных случаях. Когда эту функцию применяют для списка a, то получается объект-итератор из положительных элементов a.

>>> a = [1, -4, 6, 8, -10]
>>> def func(x):
...     if x > 0:
...             return 1
...     else:
...             return 0
... 
>>> b = filter(func, a)
>>> b = list(b)
>>> b
[1, 6, 8]



