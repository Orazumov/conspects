Алгоритмы и структуры данных Python.

def rvreverver ():
asser n < 999, 'Слишком большое число'

если n более 999, то вызывается исключение с указанным
описанием.

Лучше всех константы сохранять в переменных, а потом 
уже использовать в коде.

Изменяемые и неизменяемые типы данных:

Изменяемый:
Список
Конкатениция создала новый объект в памяти:

a = a + [4, 5]

а - новый объект.

Это всегда так, независимо от типа.

a += [4,5 ] == a.extend([4,5]) - это расширение
существующего объекта, а не создается новый.

Изменяемые:
списки (list), множества (set), словари (dict)

Неизменяемые:
числовые данные (int, float, complex), 
символьные строки (class 'str'), кортежи (tuple).

Ключем словая всегда должен быть неизменяемый тип
данных.

(это защита от того, что в дальнейшем ключ не изменится
и хэш ф. будет выдавать одно и то же значение).

Там где генерировать массивы, берем код из лекции.

Вставка - увеличение количества элементов в массиве на 1.

!!! В рамках ПЗ нужно делать минимум 3 замера кода.

осваиваем timeit
cProfile

По размеру входных данных N определяем время T:

print(timeit.timeit('func(10)', number = 10, globals=globals()))

увеличиваем количество входных данных, а не повторений!

Не для оценки времени, а для поиска слабых мест в коде:

cProfile.run('main(100000)')

В таблице видим сколько раз вызывался код и сколько времени
занял каждый кусочек кода.

cumtime - накопительное время
tottime - общее время кусочка кода
percall - время кусочка кода на 1 вызов

Можно разбивать большой код по маленьким кусочкам и смотреть каждый из них.

получив замеры, вставим их в код в виде комментария.

есть модуль:

import functools

@functools.lru_cache()
def fib(n):
	if n < 2:
		return n
		
	return fib(n - 1) + fib(n - 2)

декоратор сохраняет значения в словаре в кэше.
вычисляется реально только 1 раз, остальные 100
замеров при оценке асимптотики будут браться из 
кэша.

из кода исключаем input и print, они искажают время
замера.









